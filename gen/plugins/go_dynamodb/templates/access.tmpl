import (
    "context"
    "fmt"
    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
    "lib/config"
)

type {{$.Object.NameCamel}}ProviderBase interface {

{{- if $.HasSort}}
    Get{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}, {{$.SortField.NameCamel}} {{$.SortField.GoType}}) (ret *{{$.Object.NameTitle}}, err error)
{{- else}}
    Get{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}) (ret *{{$.Object.NameTitle}}, err error)
{{- end}}
    Put{{$.Object.NameTitle}}(ctx context.Context, {{$.Object.NameCamel}} *{{$.Object.NameTitle}}) error
    GetPut({{$.Object.NameCamel}} *{{$.Object.NameTitle}}) (put *types.Put, err error)
{{- if $.HasSort}}
    Delete{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}, {{$.SortField.NameCamel}} {{$.SortField.GoType}}) error
{{- else}}
    Delete{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}) error
{{- end}}
    Scan{{$.Object.NameTitle}}(ctx context.Context) (ret []*{{$.Object.NameTitle}}, err error)
{{- if $.HasSort}}
    BatchGet{{$.Object.NameTitle}}(ctx context.Context, rows []BatchGetInput{{$.Object.NameTitle}}) (ret []*{{$.Object.NameTitle}}, err error)
    BatchGet{{$.Object.NameTitle}}By{{$.HashField.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}, rows []{{$.SortField.GoType}}) (ret []*{{$.Object.NameTitle}}, err error)
{{- else}}
    BatchGet{{$.Object.NameTitle}}(ctx context.Context, rows []{{$.HashField.GoType}}) (ret []*{{$.Object.NameTitle}}, err error)
{{- end}}
{{- if $.HasSort}}
    List{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoTypeRequired}}) (ret []*{{$.Object.NameTitle}}, err error)
{{- end}}
{{-  if $.GSIs }}
    {{-  range $gsi := $.GSIs }}
        {{-  if and ($gsi.HasSort) (ne $gsi.HashKey $gsi.Name) }}
            List{{$.Object.NameTitle}}By{{$gsi.GoName}}(ctx context.Context, {{$gsi.HashField.NameCamel}} {{$gsi.HashField.GoTypeRequired}}, {{$gsi.SortField.NameCamel}} {{$gsi.SortField.GoTypeRequired}}) (ret []*{{$.Object.NameTitle}}, err error)
        {{- end}}
        List{{$.Object.NameTitle}}By{{$gsi.HashField.NameTitle}}(ctx context.Context, {{$gsi.HashField.NameCamel}} {{$gsi.HashField.GoTypeRequired}}) (ret []*{{$.Object.NameTitle}}, err error)
    {{- end}}
{{- end}}
}

type {{$.Object.NameTitle}}Impl struct {
    db *dynamodb.Client
}

var {{$.Object.NameCamel}}ProviderSingleton {{$.Object.NameTitle}}Provider

func init{{$.Object.NameTitle}}Provider(db *dynamodb.Client) {
    {{$.Object.NameCamel}}ProviderSingleton = &{{$.Object.NameTitle}}Impl{
        db: db,
    }
}

func Get{{$.Object.NameTitle}}Provider() {{$.Object.NameTitle}}Provider {
    return {{$.Object.NameCamel}}ProviderSingleton
}

var {{$.Object.NameCamel}}ExtraValidator func(*{{$.Object.NameTitle}}) error

//Validate validates the {{$.Object.NameTitle}} struct
func ({{$.Object.NameCamel}} *{{$.Object.NameTitle}}) Validate() error {
    {{- range $index, $field := $.Fields}}
        {{- if or (eq $field.Name $.HashField.Name) (eq $field.Name $.SortField.Name)}}
            {{- if eq $field.DynamoType "S"}}
            if {{$.Object.NameCamel}}.{{$field.NameTitle}} == "" {
            {{- else if eq $field.DynamoType "N"}}
            if {{$.Object.NameCamel}}.{{$field.NameTitle}} == 0 {
            {{- end}}
                return fmt.Errorf("key field {{$.Object.NameTitle}}.{{$field.Name}} is required")
            }
        {{- end}}
        {{- if and $field.Collection $field.IsCollectionOfObjects}}
            {{if eq $field.Required false }}
            if {{$.Object.NameCamel}}.{{$field.NameTitle}} != nil && len({{$.Object.NameCamel}}.{{$field.NameTitle}}) != 0 {
                for _, item := range {{$.Object.NameCamel}}.{{$field.NameTitle}} {
                    if err := item.Validate(); err != nil {
                        return err
                    }
                }
            }
            {{else}}
            if len({{$.Object.NameCamel}}.{{$field.NameTitle}}) != 0 {
                for _, item := range {{$.Object.NameCamel}}.{{$field.NameTitle}} {
                    if err := item.Validate(); err != nil {
                        return err
                    }
                }
            }
            {{end}}
        {{- end}}
    {{- end}}

    if {{$.Object.NameCamel}}ExtraValidator != nil {
        return {{$.Object.NameCamel}}ExtraValidator({{$.Object.NameCamel}})
    }
    return nil
}

func ({{$.Object.NameCamel}} *{{$.Object.NameTitle}}) key() map[string]types.AttributeValue {
    return map[string]types.AttributeValue{
        "{{$.HashField.Name}}": &types.AttributeValueMember{{$.HashField.DynamoType}} {
            {{- if eq $.HashField.DynamoType "S"}}
            Value: {{$.Object.NameCamel}}.{{$.HashField.NameTitle}},
            {{- else}}
            Value: fmt.Sprintf("%d", {{$.Object.NameCamel}}.{{$.HashField.NameTitle}}),
            {{- end}}
        },
        {{- if $.HasSort}}
        "{{$.SortField.Name}}": &types.AttributeValueMember{{$.SortField.DynamoType}} {
            {{- if eq $.SortField.DynamoType "S"}}
                Value: {{$.Object.NameCamel}}.{{$.SortField.NameTitle}},
            {{- else}}
                Value: fmt.Sprintf("%d", {{$.Object.NameCamel}}.{{$.SortField.NameTitle}}),
            {{- end}}
        },
        {{end}}
    }
}

func ({{$.Object.NameCamel}} *{{$.Object.NameTitle}}) GetMapID() string {
{{- if $.HasSort }}
    {{- if eq $.SortField.DynamoType "S"}}
    return {{$.Object.NameCamel}}.{{$.SortField.NameTitle}}
    {{- else }}
    return fmt.Sprintf("%d", {{$.Object.NameCamel}}.{{$.SortField.NameTitle}})
    {{- end }}
{{- else }}
    {{- if eq $.HashField.DynamoType "S"}}
        return {{$.Object.NameCamel}}.{{$.HashField.NameTitle}}
    {{- else }}
        return fmt.Sprintf("%d", {{$.Object.NameCamel}}.{{$.HashField.NameTitle}})
    {{- end }}
{{- end }}
}

func (p *{{$.Object.NameTitle}}Impl) tableName() *string {
    return aws.String("{{$.TableName}}-" + config.Env)
}

//Get{{$.Object.NameTitle}} gets a {{$.Object.NameTitle}} from the database
{{- if $.HasSort}}
func (p *{{$.Object.NameTitle}}Impl) Get{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}, {{$.SortField.NameCamel}} {{$.SortField.GoType}}) (ret *{{$.Object.NameTitle}}, err error) {
{{- else}}
func (p *{{$.Object.NameTitle}}Impl) Get{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}) (ret *{{$.Object.NameTitle}}, err error) {
{{- end}}
    result, err := p.db.GetItem(ctx, &dynamodb.GetItemInput{
        TableName: p.tableName(),
        Key: map[string]types.AttributeValue{
            "{{$.HashField.Name}}": &types.AttributeValueMember{{$.HashField.DynamoType}} {
                {{- if eq $.HashField.DynamoType "S"}}
                Value: {{$.HashField.NameCamel}},
                {{- else}}
                Value: fmt.Sprintf("%d", {{$.HashField.NameCamel}}),
                {{- end}}
            },
            {{- if $.HasSort}}
            "{{$.SortField.Name}}": &types.AttributeValueMember{{$.SortField.DynamoType}} {
                {{- if eq $.SortField.DynamoType "S"}}
                    Value: {{$.SortField.NameCamel}},
                {{- else}}
                    Value: fmt.Sprintf("%d", {{$.SortField.NameCamel}}),
                {{- end}}
            },
            {{end}}
        },
    })
    if err != nil {
        return nil, fmt.Errorf("failed to get {{$.Object.NameTitle}} from table with id %s: %v", {{$.HashField.NameCamel}}, err)
    }
    ret = &{{$.Object.NameTitle}}{}

    err = attributevalue.UnmarshalMap(result.Item, ret)
    if err != nil {
        return nil, fmt.Errorf("failed to unmarshal {{$.Object.NameTitle}} from table with id %s: %v", {{$.HashField.NameCamel}}, err)
    }
    return ret, nil
}

//Put{{$.Object.NameTitle}} puts a {{$.Object.NameTitle}} into the database
func (p *{{$.Object.NameTitle}}Impl) Put{{$.Object.NameTitle}}(ctx context.Context, {{$.Object.NameCamel}} *{{$.Object.NameTitle}}) error {
    if err := {{$.Object.NameCamel}}.Validate(); err != nil {
        return err
    }
    item, err := attributevalue.MarshalMap({{$.Object.NameCamel}})
    if err != nil {
        return fmt.Errorf("failed to marshal {{$.Object.NameTitle}}: %v", err)
    }
    _, err = p.db.PutItem(ctx, &dynamodb.PutItemInput{
        TableName: p.tableName(),
        Item:      item,
    })
    if err != nil {
        return fmt.Errorf("failed to put {{$.Object.NameTitle}} into table: %v", err)
    }
    return nil
}

// GetPut returns a Put entry for a {{$.Object.NameTitle}}
func (p *{{$.Object.NameTitle}}Impl) GetPut({{$.Object.NameCamel}} *{{$.Object.NameTitle}}) (put *types.Put, err error) {
	if err := {{$.Object.NameCamel}}.Validate(); err != nil {
		return nil, err
	}
	item, err := attributevalue.MarshalMap({{$.Object.NameCamel}})
	if err != nil {
		return nil, fmt.Errorf("failed to marshal {{$.Object.NameTitle}}: %v", err)
	}
	return &types.Put{
		TableName: p.tableName(),
		Item:      item,
	}, nil
}

//Delete{{$.Object.NameTitle}} deletes a {{$.Object.NameTitle}} from the database
{{- if $.HasSort}}
func (p *{{$.Object.NameTitle}}Impl) Delete{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}, {{$.SortField.NameCamel}} {{$.SortField.GoType}}) error {
{{- else}}
func (p *{{$.Object.NameTitle}}Impl) Delete{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}) error {
{{- end}}
    _, err := p.db.DeleteItem(ctx, &dynamodb.DeleteItemInput{
        TableName: p.tableName(),
        Key: map[string]types.AttributeValue{
            "{{$.HashField.Name}}": &types.AttributeValueMember{{$.HashField.DynamoType}} {
            {{- if eq $.HashField.DynamoType "S"}}
                Value: {{$.HashField.NameCamel}},
            {{- else}}
                Value: fmt.Sprintf("%d", {{$.HashField.NameCamel}}),
            {{- end}}
            },
            {{- if $.HasSort}}
                "{{$.SortField.Name}}": &types.AttributeValueMember{{$.SortField.DynamoType}} {
                {{- if eq $.SortField.DynamoType "S"}}
                    Value: {{$.SortField.NameCamel}},
                {{- else}}
                    Value: fmt.Sprintf("%d", {{$.SortField.NameCamel}}),
                {{- end}}
                },
            {{end}}
        },
    })
    if err != nil {
        return fmt.Errorf("failed to delete {{$.Object.NameTitle}} from table with id %s: %v", {{$.HashField.NameCamel}}, err)
    }
    return nil
}

//Scan{{$.Object.NameTitle}} scans the {{$.Object.NameTitle}} table
func (p *{{$.Object.NameTitle}}Impl) Scan{{$.Object.NameTitle}}(ctx context.Context) (ret []*{{$.Object.NameTitle}}, err error) {
    var lastEvaluatedKey map[string]types.AttributeValue
    for {
        scanResp, err := p.db.Scan(ctx, &dynamodb.ScanInput{
            TableName: p.tableName(),
            ExclusiveStartKey: lastEvaluatedKey,
        })
        if err != nil {
            return nil, fmt.Errorf("failed to scan Activity table: %v", err)
        }
        temp := make([]*{{$.Object.NameTitle}}, 0, len(scanResp.Items))
        err = attributevalue.UnmarshalListOfMaps(scanResp.Items, &temp)
        if err != nil {
            return nil, fmt.Errorf("failed to unmarshal {{$.Object.NameTitle}} table: %v", err)
        }
        ret = append(ret, temp...)
        if scanResp.LastEvaluatedKey == nil {
            break
        } else {
            lastEvaluatedKey = scanResp.LastEvaluatedKey
        }
    }
    return ret, nil
}

{{- if $.HasSort}}
//BatchGetInput{{$.Object.NameTitle}} represents the keys to fetch {{$.Object.NameTitle}} from the database
type BatchGetInput{{$.Object.NameTitle}} struct {
    {{$.HashField.NameTitle}} {{$.HashField.GoType}}
    {{$.SortField.NameTitle}} {{$.SortField.GoType}}
}

//BatchGet{{$.Object.NameTitle}} retrieves multiple {{$.Object.NameTitle}} from the database
func (p *{{$.Object.NameTitle}}Impl) BatchGet{{$.Object.NameTitle}}(ctx context.Context, rows []BatchGetInput{{$.Object.NameTitle}}) (ret []*{{$.Object.NameTitle}}, err error) {
{{- else}}
//BatchGet{{$.Object.NameTitle}} retrieves multiple {{$.Object.NameTitle}} from the database
func (p *{{$.Object.NameTitle}}Impl) BatchGet{{$.Object.NameTitle}}(ctx context.Context, rows []{{$.HashField.GoType}}) (ret []*{{$.Object.NameTitle}}, err error) {
{{- end}}
    keys := make([]map[string]types.AttributeValue, 0, len(rows))
    for _, val := range rows {
        keys = append(keys, map[string]types.AttributeValue{
            {{- if $.HasSort}}
            "{{$.HashField.Name}}": &types.AttributeValueMember{{$.HashField.DynamoType}} {
                {{- if eq $.HashField.DynamoType "S"}}
                    Value: val.{{$.HashField.NameTitle}},
                {{- else}}
                    Value: fmt.Sprintf("%d", val.{{$.HashField.NameTitle}}),
                {{- end}}
            },
            "{{$.SortField.Name}}": &types.AttributeValueMember{{$.SortField.DynamoType}} {
                {{- if eq $.SortField.DynamoType "S"}}
                    Value: val.{{$.SortField.NameTitle}},
                {{- else}}
                    Value: fmt.Sprintf("%d", val.{{$.SortField.NameTitle}}),
                {{- end}}
            },
            {{- else}}
            "{{$.HashField.Name}}": &types.AttributeValueMember{{$.HashField.DynamoType}} {
                Value: val,
            },
            {{- end}}
        })
    }
    result, err := p.db.BatchGetItem(ctx, &dynamodb.BatchGetItemInput{
        RequestItems: map[string]types.KeysAndAttributes{
            *p.tableName(): {
                Keys: keys,
            },
        },
    })
    if err != nil {
        return nil, fmt.Errorf("failed to batch get {{$.Object.NameTitle}} from table: %v", err)
    }
    ret = make([]*{{$.Object.NameTitle}}, 0, len(result.Responses[*p.tableName()]))
    err = attributevalue.UnmarshalListOfMaps(result.Responses[*p.tableName()], &ret)
    if err != nil {
        return nil, fmt.Errorf("failed to unmarshal from table: %v", err)
    }
    return ret, nil
}

{{- if $.HasSort}}
//BatchGet{{$.Object.NameTitle}}By{{$.HashField.NameTitle}} retrieves multiple {{$.Object.NameTitle}} from the database with a common {{$.HashField.NameTitle}}
func (p *{{$.Object.NameTitle}}Impl) BatchGet{{$.Object.NameTitle}}By{{$.HashField.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoType}}, rows []{{$.SortField.GoType}}) (ret []*{{$.Object.NameTitle}}, err error) {
    keys := make([]map[string]types.AttributeValue, 0, len(rows))
    for _, val := range rows {
        keys = append(keys, map[string]types.AttributeValue{
            "{{$.HashField.Name}}": &types.AttributeValueMember{{$.HashField.DynamoType}} {
                {{- if eq $.HashField.DynamoType "S"}}
                    Value: {{$.HashField.NameCamel}},
                {{- else}}
                    Value: fmt.Sprintf("%d", {{$.HashField.NameCamel}}),
                {{- end}}
            },
            "{{$.SortField.Name}}": &types.AttributeValueMember{{$.SortField.DynamoType}} {
                {{- if eq $.SortField.DynamoType "S"}}
                    Value: val,
                {{- else}}
                    Value: fmt.Sprintf("%d", val),
                {{- end}}
            },
        })
    }
    result, err := p.db.BatchGetItem(ctx, &dynamodb.BatchGetItemInput{
        RequestItems: map[string]types.KeysAndAttributes{
            *p.tableName(): {
                Keys: keys,
            },
        },
    })
    if err != nil {
        return nil, fmt.Errorf("failed to batch get {{$.Object.NameTitle}} from table: %v", err)
    }
    ret = make([]*{{$.Object.NameTitle}}, 0, len(result.Responses[*p.tableName()]))
    err = attributevalue.UnmarshalListOfMaps(result.Responses[*p.tableName()], &ret)
    if err != nil {
        return nil, fmt.Errorf("failed to unmarshal from table: %v", err)
    }
    return ret, nil
}
{{- end }}

{{- if $.HasSort}}
//List{{$.Object.NameTitle}} gets a list of {{$.Object.NameTitle}} from the database using the hash key
func (p *{{$.Object.NameTitle}}Impl) List{{$.Object.NameTitle}}(ctx context.Context, {{$.HashField.NameCamel}} {{$.HashField.GoTypeRequired}}) (ret []*{{$.Object.NameTitle}}, err error) {
    var lastEvaluatedKey map[string]types.AttributeValue
    for {
        resp, err := p.db.Query(ctx, &dynamodb.QueryInput{
            TableName: p.tableName(),
            KeyConditions: map[string]types.Condition{
                "{{$.HashField.Name}}": {
                    ComparisonOperator: types.ComparisonOperatorEq,
                    AttributeValueList: []types.AttributeValue{
                        &types.AttributeValueMember{{$.HashField.DynamoType}}{
                            Value: {{$.HashField.NameCamel}},
                        },
                    },
                },
            },
            ExclusiveStartKey: lastEvaluatedKey,
        })
        if err != nil {
            return nil, fmt.Errorf("failed to query {{$.Object.NameTitle}} table by hash: %v", err)
        }
        temp := make([]*{{$.Object.NameTitle}}, 0, len(resp.Items))
        err = attributevalue.UnmarshalListOfMaps(resp.Items, &temp)
        if err != nil {
            return nil, fmt.Errorf("failed to unmarshal {{$.Object.NameTitle}} table: %v", err)
        }
        ret = append(ret, temp...)
        if resp.LastEvaluatedKey == nil {
            break
        } else {
            lastEvaluatedKey = resp.LastEvaluatedKey
        }
    }
    return ret, nil
}
{{- end}}

{{-  if $.GSIs }}
    {{-  range $gsi := $.GSIs }}
{{-  if and ($gsi.SortKey) (ne $gsi.HashKey $gsi.Name) }}

//List{{$.Object.NameTitle}}By{{$gsi.GoName}} gets a list of {{$.Object.NameTitle}} from the database using the {{ $gsi.Name }} GSI
func (p *{{$.Object.NameTitle}}Impl) List{{$.Object.NameTitle}}By{{$gsi.GoName}}(ctx context.Context, {{$gsi.HashField.NameCamel}} {{$gsi.HashField.GoTypeRequired}}, {{$gsi.SortField.NameCamel}} {{$gsi.SortField.GoTypeRequired}}) (ret []*{{$.Object.NameTitle}}, err error) {
    var lastEvaluatedKey map[string]types.AttributeValue
    for {
        resp, err := p.db.Query(ctx, &dynamodb.QueryInput{
            TableName: p.tableName(),
            IndexName: aws.String("{{$gsi.Name}}"),
            KeyConditions: map[string]types.Condition{
                "{{$gsi.HashField.Name}}": {
                    ComparisonOperator: types.ComparisonOperatorEq,
                    AttributeValueList: []types.AttributeValue{
                        &types.AttributeValueMember{{$gsi.HashField.DynamoType}}{
                            Value: {{$gsi.HashField.NameCamel}},
                        },
                    },
                },
                "{{$gsi.SortField.Name}}": {
                    ComparisonOperator: types.ComparisonOperatorEq,
                    AttributeValueList: []types.AttributeValue{
                        &types.AttributeValueMember{{$gsi.SortField.DynamoType}}{
                            Value: {{$gsi.SortField.NameCamel}},
                        },
                    },
                },
            },
            ExclusiveStartKey: lastEvaluatedKey,
        })
        if err != nil {
            return nil, fmt.Errorf("failed to query {{$.Object.NameTitle}} table via {{$gsi.Name}} complete: %v", err)
        }
        temp := make([]*{{$.Object.NameTitle}}, 0, len(resp.Items))
        err = attributevalue.UnmarshalListOfMaps(resp.Items, &temp)
        if err != nil {
            return nil, fmt.Errorf("failed to unmarshal {{$.Object.NameTitle}} table: %v", err)
        }
        ret = append(ret, temp...)
        if resp.LastEvaluatedKey == nil {
            break
        } else {
            lastEvaluatedKey = resp.LastEvaluatedKey
        }
    }
    return ret, nil
}

{{- end}}

//List{{$.Object.NameTitle}}By{{$gsi.HashField.NameTitle}} gets a list of {{$.Object.NameTitle}} from the database using the {{ $gsi.Name }} GSI
func (p *{{$.Object.NameTitle}}Impl) List{{$.Object.NameTitle}}By{{$gsi.HashField.NameTitle}}(ctx context.Context, {{$gsi.HashField.NameCamel}} {{$gsi.HashField.GoTypeRequired}}) (ret []*{{$.Object.NameTitle}}, err error) {
    var lastEvaluatedKey map[string]types.AttributeValue
    for {
        resp, err := p.db.Query(ctx, &dynamodb.QueryInput{
            TableName: p.tableName(),
            IndexName: aws.String("{{$gsi.Name}}"),
            KeyConditions: map[string]types.Condition{
                "{{$gsi.HashField.Name}}": {
                    ComparisonOperator: types.ComparisonOperatorEq,
                    AttributeValueList: []types.AttributeValue{
                        &types.AttributeValueMember{{$gsi.HashField.DynamoType}}{
                            Value: {{$gsi.HashField.NameCamel}},
                        },
                    },
                },
            },
            ExclusiveStartKey: lastEvaluatedKey,
        })
        if err != nil {
            return nil, fmt.Errorf("failed to query {{$.Object.NameTitle}} table via {{$gsi.Name}} complete: %v", err)
        }
        temp := make([]*{{$.Object.NameTitle}}, 0, len(resp.Items))
        err = attributevalue.UnmarshalListOfMaps(resp.Items, &temp)
        if err != nil {
            return nil, fmt.Errorf("failed to unmarshal {{$.Object.NameTitle}} table: %v", err)
        }
        ret = append(ret, temp...)
        if resp.LastEvaluatedKey == nil {
            break
        } else {
            lastEvaluatedKey = resp.LastEvaluatedKey
        }
    }
    return ret, nil
}
{{- end}}
{{- end}}