import (
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

type multiTableMock struct {
}

func initMultiTableProviderMock() {
	multiTableProviderSingleton = &multiTableMock{}
}

func (p *multiTableMock) TransactionMerchOrder(ctx context.Context, order *Order, merchOrders []*MerchOrder, merchTypes map[string]int, adminOverride bool) (success bool, err error) {

	mtProvider := GetMerchTypeProvider()
	moProvider := GetMerchOrderProvider()
	ordProvider := GetOrderProvider()

	mtMap := make(map[string]*MerchType, len(merchTypes))

	for mtID, qty := range merchTypes {
		mt, err := mtProvider.GetMerchType(ctx, mtID)
		if err != nil {
			return false, fmt.Errorf("failed GetMerchType %s: %w", mtID, err)
		}

		if !adminOverride && mt.QtyAvailable != nil && *mt.QtyAvailable < qty {
			return false, fmt.Errorf("insufficient quantity for %s", mtID)
		}

		mtMap[mtID] = mt
	}

	for mtID, qty := range merchTypes {
		mt := mtMap[mtID]
		*mt.QtyAvailable -= qty
		_ = mtProvider.PutMerchType(ctx, mt)
	}

	for _, v := range merchOrders {
		_ = moProvider.PutMerchOrder(ctx, v)
	}

	_ = ordProvider.PutOrder(ctx, order)

	return true, nil
}

func (p *multiTableMock) BulkReserve(ctx context.Context, eventId string, bookingTypes map[string]int, activities map[string]int, transportTypes map[string]int, upgrade map[string]int, adminOverride bool, extras []types.TransactWriteItem) (success bool, err error) {

	items := make([]types.TransactWriteItem, 0, len(bookingTypes)+len(activities)+len(transportTypes)+1+len(extras))
	items = append(items, extras...)

	btProvider := GetBookingTypeProvider()
	actProvider := GetActivityProvider()
	ttProvider := GetTransportTypeProvider()
	upgProvider := GetUpgradeProvider()

	btMap := make(map[string]*BookingType)
	actMap := make(map[string]*Activity)
	ttMap := make(map[string]*TransportType)
	upgMap := make(map[string]*Upgrade)

	for btID, qty := range bookingTypes {
		bt, err := btProvider.GetBookingType(ctx, eventId, btID)
		if err != nil {
			return false, fmt.Errorf("failed GetBookingType %s: %w", btID, err)
		}

		if !adminOverride && bt.QtyAvailable < qty {
			return false, fmt.Errorf("insufficient quantity for booking type %s", btID)
		}

		btMap[btID] = bt
	}

	for actID, qty := range activities {
		act, err := actProvider.GetActivity(ctx, eventId, actID)
		if err != nil {
			return false, fmt.Errorf("failed GetActivity %s: %w", actID, err)
		}

		if !adminOverride && act.QtyAvailable != nil && *act.QtyAvailable < qty {
			return false, fmt.Errorf("insufficient quantity for activity %s", actID)
		}

		actMap[actID] = act
	}

	for ttID, qty := range transportTypes {
		tt, err := ttProvider.GetTransportType(ctx, eventId, ttID)
		if err != nil {
			return false, fmt.Errorf("failed GetTransportType %s: %w", ttID, err)
		}

		if !adminOverride && tt.QtyAvailable < qty {
			return false, fmt.Errorf("insufficient quantity for transport type %s", ttID)
		}

		ttMap[ttID] = tt
	}

	for upgID, qty := range upgrade {
		upg, err := upgProvider.GetUpgrade(ctx, eventId, upgID)
		if err != nil {
			return false, fmt.Errorf("failed GetUpgrade %s: %w", upgID, err)
		}

		if !adminOverride && upg.QtyAvailable < qty {
			return false, fmt.Errorf("insufficient quantity for upgrade %s", upgID)
		}

		upgMap[upgID] = upg
	}

	for _, v := range extras {
		if v.Update != nil {
			return false, fmt.Errorf("mock extra does not support Update")
		}
		if v.Delete != nil {
			return false, fmt.Errorf("mock extra does not support Delete")
		}
		if v.ConditionCheck != nil {
			return false, fmt.Errorf("mock extra does not support ConditionCheck")
		}
		if v.Put == nil {
			return false, fmt.Errorf("mock extra missing Put")
		}
	}

	for btID, qty := range bookingTypes {
		bt := btMap[btID]
		bt.QtyAvailable -= qty
		_ = btProvider.PutBookingType(ctx, bt)
	}

	for actID, qty := range activities {
		act := actMap[actID]
		if act.QtyAvailable == nil {
			continue
		}
		*act.QtyAvailable -= qty
		_ = actProvider.PutActivity(ctx, act)
	}

	for ttID, qty := range transportTypes {
		tt := ttMap[ttID]
		tt.QtyAvailable -= qty
		_ = ttProvider.PutTransportType(ctx, tt)
	}

	for upgID, qty := range upgrade {
		upg := upgMap[upgID]
		upg.QtyAvailable -= qty
		_ = upgProvider.PutUpgrade(ctx, upg)
	}

	for _, v := range extras {
		p := v.Put
		switch *p.TableName {
		case "Order":
			order := &Order{}
			_ = attributevalue.UnmarshalMap(p.Item, order)
			_ = GetOrderProvider().PutOrder(ctx, order)
		case "Ticket":
			ticket := &Ticket{}
			_ = attributevalue.UnmarshalMap(p.Item, ticket)
			_ = GetTicketProvider().PutTicket(ctx, ticket)
		case "ActivityTicket":
			activityTicket := &ActivityTicket{}
			_ = attributevalue.UnmarshalMap(p.Item, activityTicket)
			_ = GetActivityTicketProvider().PutActivityTicket(ctx, activityTicket)
		case "TransportBooking":
			transportBooking := &TransportBooking{}
			_ = attributevalue.UnmarshalMap(p.Item, transportBooking)
			_ = GetTransportBookingProvider().PutTransportBooking(ctx, transportBooking)
		case "UpgradeBooking":
			upgradeBooking := &UpgradeBooking{}
			_ = attributevalue.UnmarshalMap(p.Item, upgradeBooking)
			_ = GetUpgradeBookingProvider().PutUpgradeBooking(ctx, upgradeBooking)
		default:
			return false, fmt.Errorf("unknown extras Put table: %s", *p.TableName)
		}
	}

	return true, nil
}
